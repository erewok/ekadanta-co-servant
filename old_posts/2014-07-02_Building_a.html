<p>I am a beginner at Haskell, and I'll save you from what I have found compelling about the language, but suffice it to say that it requires new patterns of thought and this in itself can be compelling.</p>

<p>Wittgenstein wrote,</p>
<blockquote>Show me a language, and I'll show you a way of seeing the world.</blockquote>

<p>And I have found this to be true of programming languages as well, which see the world as filtered through the lens of information problems that need to be solved. Different languages solve problems differently, and sometimes new languages can reveal problems you didn't even know you had. In short, learning new and different languages can be an exercise in critical thinking, and this is something that Haskell, certainly, requires a lot of.</p>

<p>Now, I do a lot of HTML parsing in my day job and in my life as a hobbyist programmer because there's just so much data out there on the web to open your arms and receive. Thus, one of the first things I look for in a language (after an HTTP library) is an HTML parser. In this case, however, I decided it might be a solid exercise to try my hand at building one of these myself.</p> 

<p>In addition to tackling a new language, such a task also offers lots of opportunities for thinking in data structures and data problems as a result of building an interpreter. It's tough for those of us still struggling to think of ourselves as engineers, in other words, but one thing I'm doing along the way is recording my challenges.</p>

<p>Herein is a catalog of my attempts to solve this problem using Haskell. There are probably many oversights and errors I have made along the way, but I figure sharing what I have learned may be beneficial to others who are on the same journey.</p>

<p>First: using <code>Data.Text</code> instead of <code>String</code> Link to that reddit thread</p>

<blockquote>I will, in fact, claim that the difference between a bad programmer and a good one is whether he considers his code or his data structures more important.</blockquote>

<p>In line with Linus Torvalds' sentiment above, I started my parser thinking about what the data structures should look like. This is something I've found true with Haskell: I spend a lot more time thinking about what the data looks like instead of what a program should <em>do</em>. It's a kind of pleasing discovery actually, that I can think about how to define a set of rules for my data and Haskell helps run through the data I've defined.</p>

<p>Third, tag names and attributes</p>

<p>How to parse? Look for start and ends? How to know if a tag is self-closing??</p>

<p>Fourth, building the tree...</p>

<p>So, how'd we do? Aside from subjective attempts to make it readable, I can't comment on the beauty or subtlety of the code because of my inexperience with Haskell. By contrast, one way to score our efforts is to consider the time-complexity of the code. Using a language like Haskell after working in Python all day is liable to make one feel like stepping up from a Volkswagen Bus to a Porsche; it's definitely fast. It's so fast that running these things on the command line often violates my expectation that the program ran at all. Even so, my limited experience with asymptotic time complexity has taught me that your programs will only scale if you have considered them at their worst. I'm self-taught at this practice as well, so this is going to be a rough sketch, and I will happily take suggestions here and elsewhere on where I've screwed up. -> Analysis of time complexity</p>